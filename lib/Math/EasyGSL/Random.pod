=head1 GNU Scientific Library -- Reference Manual

=head2 18 Random Number Generation

 The library provides a large
collection of random number generators which can be accessed through a
uniform interface. Environment variables allow you to select different
generators and seeds at runtime, so that you can easily switch between
generators without needing to recompile your program. Each instance of
a generator keeps track of its own state, allowing the generators to be
used in multi-threaded programs. Additional functions are available for
transforming uniform random numbers into samples from continuous or
discrete probability distributions such as the Gaussian, log-normal or
Poisson distributions.

=head2 CONSTRUCTOR

=head3 new

 gsl_rng * B<gsl_rng_alloc> (I<const gsl_rng_type * T>)

This function returns a pointer to a
newly-created instance of a random number generator of type I<T>. For
example, the following code creates an instance of the Tausworthe
generator,

If there is insufficient memory to create the generator then the
function returns a null pointer and the error handler is invoked with
an error code of C<GSL_ENOMEM>.

The generator is automatically initialized with the default seed,
C<gsl_rng_default_seed>. This is zero by default but can be changed
either directly or by using the environment variable C<GSL_RNG_SEED>
(see L<Random number environment
variables|#Random-number-environment-variables>).

XXX env

=head2 Random number environment variables

The library allows you to choose a default generator and seed from the
environment variables C<GSL_RNG_TYPE> and C<GSL_RNG_SEED> and the
function C<gsl_rng_env_setup>. This makes it easy try out different
generators and seeds without having to recompile your program.

=head3 rng_env_setup

 const gsl_rng_type * B<gsl_rng_env_setup> (I<void>)

This
function reads the environment variables C<GSL_RNG_TYPE> and
C<GSL_RNG_SEED> and uses their values to set the corresponding library
variables C<gsl_rng_default> and C<gsl_rng_default_seed>. These global
variables are defined as follows,

          extern const gsl_rng_type *gsl_rng_default
          extern unsigned long int gsl_rng_default_seed

The environment variable C<GSL_RNG_TYPE> should be the name of a
generator, such as C<taus> or C<mt19937>. The environment variable
C<GSL_RNG_SEED> should contain the desired seed value. It is converted
to an C<unsigned long int> using the C library function C<strtoul>.

If you don't specify a generator for C<GSL_RNG_TYPE> then
C<gsl_rng_mt19937> is used as the default. The initial value of
C<gsl_rng_default_seed> is zero.

XXX available generator types

=head1 METHODS - Basic interface

=head3 seed

 void B<gsl_rng_set> (I<const gsl_rng * r, unsigned long int s>)

This function initializes (or `seeds') the random number generator. If
the generator is seeded with the same value of I<s> on two different
runs, the same stream of random numbers will be generated by successive
calls to the routines below. If different values of I<s> E<gt>= 1 are
supplied, then the generated streams of random numbers should be
completely different. If the seed I<s> is zero then the standard seed
from the original implementation is used instead. For example, the
original Fortran source code for the C<ranlux> generator used a seed of
314159265, and so choosing I<s> equal to zero reproduces this when
using C<gsl_rng_ranlux>.

When using multiple seeds with the same generator, choose seed values
greater than zero to avoid collisions with the default setting.

Note that the most generators only accept 32-bit seeds, with higher
values being reduced modulo 2^32. For generators with smaller ranges
the maximum seed value will typically be lower.

=head3 rand

  $r = $self->rand;

xxx

=head3 irand

  $r = $self->irand;

xxx

=head3 get_raw

 unsigned long int B<gsl_rng_get> (I<const gsl_rng * r>)

This function returns a  random integer from 
the generator I<r>. The minimum and maximum values depend on the 
algorithm used, but all integers in the range [I<min>,I<max>] are 
equally likely. The values of I<min> and I<max> can determined using 
the auxiliary functions C<gsl_rng_max (r)> and C<gsl_rng_min (r)>.


=head3 rng_name

 const char * B<gsl_rng_name> (I<const gsl_rng * r>)

This function returns a pointer to the name of the generator. 

=head3 rng_max

 unsigned long int B<gsl_rng_max> (I<const gsl_rng * r>)

C<gsl_rng_max> returns the largest value that C<gsl_rng_get> can
return.

=head3 rng_min

 unsigned long int B<gsl_rng_min> (I<const gsl_rng * r>)

C<gsl_rng_min> returns the smallest value that C<gsl_rng_get> can
return. Usually this value is zero. There are some generators with
algorithms that cannot return zero, and for these generators the
minimum value is 1.

=head3 rng_state

 void * B<gsl_rng_state> (I<const gsl_rng * r>)

=head3 rng_size

 size_t B<gsl_rng_size> (I<const gsl_rng * r>)

These functions return a pointer to the state of generator I<r> and its
size. You can use this information to access the state directly. 

=head1 METHODS - Sampling from a random number generator

This chapter describes methods for getting random values according different 
probability distributions.

=head2 Uniform distribution

=head3 get_uniform

 double B<gsl_rng_uniform> (I<const gsl_rng * r>)

This function returns a double precision floating point number
uniformly distributed in the range [0,1). The range includes 0.0 but
excludes 1.0. The value is typically obtained by dividing the result of
C<gsl_rng_get(r)> by C<gsl_rng_max(r) + 1.0> in double precision. Some
generators compute this ratio internally so that they can provide
floating point numbers with more than 32 bits of randomness (the
maximum number of bits that can be portably represented in a single
C<unsigned long int>).

=head3 rng_uniform_pos

 double B<gsl_rng_uniform_pos> (I<const gsl_rng * r>)

This function returns a positive double precision floating point number
uniformly distributed in the range (0,1), excluding both 0.0 and 1.0.
The number is obtained by sampling the generator with the algorithm of
C<gsl_rng_uniform> until a non-zero value is obtained. You can use this
function if you need to avoid a singularity at 0.0.

=head3 rng_uniform_int

 unsigned long int B<gsl_rng_uniform_int> (I<const gsl_rng * r, unsigned long int n>)

This function returns a random integer from 0 to n-1 inclusive by
scaling down and/or discarding samples from the generator I<r>. All
integers in the range [0,n-1] are produced with equal probability. For
generators with a non-zero minimum value an offset is applied so that
zero is returned with the correct probability.

Note that this function is designed for sampling from ranges smaller
than the range of the underlying generator. The parameter I<n> must be
less than or equal to the range of the generator I<r>. If I<n> is
larger than the range of the generator then the function calls the
error handler with an error code of C<GSL_EINVAL> and returns zero.

In particular, this function is not intended for generating the full
range of unsigned integer values [0,2^32-1]. Instead choose a generator
with the maximal integer range and zero minimum value, such as
C<gsl_rng_ranlxd1>, C<gsl_rng_mt19937> or C<gsl_rng_taus>, and sample
it directly using C<gsl_rng_get>. The range of each generator can be
found using the auxiliary functions described in the next section.

=head2 The Gaussian Distribution

=head3 get_gaussian

 double B<gsl_ran_gaussian> (I<const gsl_rng * r, double sigma>)

This function returns a Gaussian
random variate, with mean zero and standard deviation I<sigma>. The
probability distribution for Gaussian random variates is, for x in the
range -\infty to +\infty. Use the transformation z = \mu + x on the
numbers returned by C<gsl_ran_gaussian> to obtain a Gaussian
distribution with mean \mu. This function uses the Box-Muller algorithm
which requires two calls to the random number generator I<r>.

=head3 get_gaussian_pdf

 double B<gsl_ran_gaussian_pdf> (I<double x, double sigma>)

This function computes the probability density p(x) at I<x> for a
Gaussian distribution with standard deviation I<sigma>, using the
formula given above.

=head3 get_gaussian_ziggurat

 double B<gsl_ran_gaussian_ziggurat> (I<const gsl_rng * r, double sigma>)

=head3 get_gaussian_ratio_method

 double B<gsl_ran_gaussian_ratio_method> (I<const gsl_rng * r, double sigma>)

This function computes a Gaussian random
variate using the alternative Marsaglia-Tsang ziggurat and
Kinderman-Monahan-Leva ratio methods. The Ziggurat algorithm is the
fastest available algorithm in most cases.

=head3 get_ugaussian

 double B<gsl_ran_ugaussian> (I<const gsl_rng * r>)

These functions compute results for the unit Gaussian distribution.
They are equivalent to the functions above with a standard deviation of
one, I<sigma> = 1.

=head2 The Gaussian Tail Distribution

=head3 get_gaussian_tail

 double B<gsl_ran_gaussian_tail> (I<const gsl_rng * r, double a, double sigma>)

This function provides random
variates from the upper tail of a Gaussian distribution with standard
deviation I<sigma>. The values returned are larger than the lower limit
I<a>, which must be positive. The method is based on Marsaglia's famous
rectangle-wedge-tail algorithm (Ann. Math. Stat. 32, 894899 (1961)),
with this aspect explained in Knuth, v2, 3rd ed, p139,586 (exercise
11).

The probability distribution for Gaussian tail random variates is, for
x E<gt> a where N(a;\sigma) is the normalization constant,

=head3 get_ugaussian_tail

 double B<gsl_ran_ugaussian_tail> (I<const gsl_rng * r, double a>)

These functions compute results for the tail of a unit Gaussian
distribution. They are equivalent to the functions above with a
standard deviation of one, I<sigma> = 1.

=head2 The Bivariate Gaussian Distribution

=head3 get_bivariate_gaussian

 void B<gsl_ran_bivariate_gaussian> (I<const gsl_rng * r, double sigma_x, double sigma_y, double rho, double * x, double * y>)

This
function generates a pair of correlated Gaussian variates, with mean
zero, correlation coefficient I<rho> and standard deviations I<sigma_x>
and I<sigma_y> in the x and y directions. The probability distribution
for bivariate Gaussian random variates is, for x,y in the range -\infty
to +\infty. The correlation coefficient I<rho> should lie between 1 and
-1.

=head2 The Exponential Distribution

=head3 get_exponential

 double B<gsl_ran_exponential> (I<const gsl_rng * r, double mu>)

This function returns a random
variate from the exponential distribution with mean I<mu>. The
distribution is, for x E<gt>= 0.

=head2 The Laplace Distribution

=head3 get_laplace

 double B<gsl_ran_laplace> (I<const gsl_rng * r, double a>)

This
function returns a random variate from the Laplace distribution with
width I<a>. The distribution is, for -\infty E<lt> x E<lt> \infty.

=head2 The Exponential Power Distribution

=head3 get_exppow

 double B<gsl_ran_exppow> (I<const gsl_rng * r, double a, double b>)

This function returns a
random variate from the exponential power distribution with scale
parameter I<a> and exponent I<b>. The distribution is, for x E<gt>= 0.
For b = 1 this reduces to the Laplace distribution. For b = 2 it has
the same form as a Gaussian distribution, but with a = \sqrt{2} \sigma.

=head2 The Cauchy Distribution

=head3 get_cauchy

 double B<gsl_ran_cauchy> (I<const gsl_rng * r, double a>)

This function returns a random variate
from the Cauchy distribution with scale parameter I<a>. The probability
distribution for Cauchy random variates is, for x in the range -\infty
to +\infty. The Cauchy distribution is also known as the Lorentz
distribution.

=head2 The Rayleigh Distribution

=head3 get_rayleigh

 double B<gsl_ran_rayleigh> (I<const gsl_rng * r, double sigma>)

This function returns a random
variate from the Rayleigh distribution with scale parameter I<sigma>.
The distribution is, for x E<gt> 0.

=head2 The Rayleigh Tail Distribution

=head3 get_rayleigh_tail

 double B<gsl_ran_rayleigh_tail> (I<const gsl_rng * r, double a, double sigma>)

This function returns a random
variate from the tail of the Rayleigh distribution with scale parameter
I<sigma> and a lower limit of I<a>. The distribution is, for x E<gt> a.

=head2 The Landau Distribution

=head3 get_landau

 double B<gsl_ran_landau> (I<const gsl_rng * r>)

This function returns a random variate
from the Landau distribution. The probability distribution for Landau
random variates is defined analytically by the complex integral, For
numerical purposes it is more convenient to use the following
equivalent form of the integral,

=head2 The Levy alpha-Stable Distributions

=head3 get_levy

 double B<gsl_ran_levy> (I<const gsl_rng * r, double c, double alpha>)

This function returns a random variate
from the Levy symmetric stable distribution with scale I<c> and
exponent I<alpha>. The symmetric stable probability distribution is
defined by a Fourier transform, There is no explicit solution for the
form of p(x) and the library does not define a corresponding C<pdf>
function. For \alpha = 1 the distribution reduces to the Cauchy
distribution. For \alpha = 2 it is a Gaussian distribution with \sigma
= \sqrt{2} c. For \alpha E<lt> 1 the tails of the distribution become
extremely wide.

The algorithm only works for 0 E<lt> alpha E<lt>= 2.

=head2 The Levy skew alpha-Stable Distribution

=head3 get_levy_skew

 double B<gsl_ran_levy_skew> (I<const gsl_rng * r, double c, double alpha, double beta>)

This
function returns a random variate from the Levy skew stable
distribution with scale I<c>, exponent I<alpha> and skewness parameter
I<beta>. The skewness parameter must lie in the range [-1,1]. The Levy
skew stable probability distribution is defined by a Fourier transform,
When \alpha = 1 the term \tan(\pi \alpha/2) is replaced by
-(2/\pi)\log|t|. There is no explicit solution for the form of p(x) and
the library does not define a corresponding C<pdf> function. For \alpha
= 2 the distribution reduces to a Gaussian distribution with \sigma =
\sqrt{2} c and the skewness parameter has no effect. For \alpha E<lt> 1
the tails of the distribution become extremely wide. The symmetric
distribution corresponds to \beta = 0.

The algorithm only works for 0 E<lt> alpha E<lt>= 2.

The Levy alpha-stable distributions have the property that if N
alpha-stable variates are drawn from the distribution p(c, \alpha,
\beta) then the sum Y = X_1 + X_2 + \dots + X_N will also be
distributed as an alpha-stable variate, p(N^(1/\alpha) c, \alpha,
\beta).

=head2 The Gamma Distribution

=head3 get_gamma

 double B<gsl_ran_gamma> (I<const gsl_rng * r, double a, double b>)

This function returns a random variate
from the gamma distribution. The distribution function is, for x E<gt>
0.

The gamma distribution with an integer
parameter I<a> is known as the Erlang distribution.

The variates are computed using the Marsaglia-Tsang fast gamma method.
This function for this method was previously called C<gsl_ran_gamma_mt>
and can still be accessed using this name.

=head3 get_gamma_knuth

 double B<gsl_ran_gamma_knuth> (I<const gsl_rng * r, double a, double b>)

This function returns a gamma variate using the algorithms from Knuth
(vol 2).

=head2 The Flat (Uniform) Distribution

=head3 get_flat

 double B<gsl_ran_flat> (I<const gsl_rng * r, double a, double b>)

This
function returns a random variate from the flat (uniform) distribution
from I<a> to I<b>. The distribution is, if a E<lt>= x E<lt> b and 0
otherwise.

=head2 The Lognormal Distribution

=head3 get_lognormal

 double B<gsl_ran_lognormal> (I<const gsl_rng * r, double zeta, double sigma>)

This function returns a random
variate from the lognormal distribution. The distribution function is,
for x E<gt> 0.

=head2 The Chi-squared Distribution

The chi-squared distribution arises in statistics. If Y_i are n
independent Gaussian random variates with unit variance then the
sum-of-squares, has a chi-squared distribution with n degrees of
freedom.

=head3 get_chisq

 double B<gsl_ran_chisq> (I<const gsl_rng * r, double nu>)

This function returns a
random variate from the chi-squared distribution with I<nu> degrees of
freedom. The distribution function is, for x E<gt>= 0.

=head2 The F-distribution

The F-distribution arises in statistics. If Y_1 and Y_2 are chi-squared
deviates with \nu_1 and \nu_2 degrees of freedom then the ratio, has an
F-distribution F(x;\nu_1,\nu_2).

=head3 get_fdist

 double B<gsl_ran_fdist> (I<const gsl_rng * r, double nu1, double nu2>)

This function returns a random variate
from the F-distribution with degrees of freedom I<nu1> and I<nu2>. The
distribution function is, for x E<gt>= 0.

=head2 The t-distribution

The t-distribution arises in statistics. If Y_1 has a normal
distribution and Y_2 has a chi-squared distribution with \nu degrees of
freedom then the ratio, has a t-distribution t(x;\nu) with \nu degrees
of freedom.

=head3 get_tdist

 double B<gsl_ran_tdist> (I<const gsl_rng * r, double nu>)

This
function returns a random variate from the t-distribution. The
distribution function is, for -\infty E<lt> x E<lt> +\infty.

=head2 The Beta Distribution

=head3 get_beta

 double B<gsl_ran_beta> (I<const gsl_rng * r, double a, double b>)

This function returns a random variate
from the beta distribution. The distribution function is, for 0 E<lt>=
x E<lt>= 1.

=head2 The Logistic Distribution

=head3 get_logistic

 double B<gsl_ran_logistic> (I<const gsl_rng * r, double a>)

This function returns a random
variate from the logistic distribution. The distribution function is,
for -\infty E<lt> x E<lt> +\infty.

=head2 The Pareto Distribution

=head3 get_pareto

 double B<gsl_ran_pareto> (I<const gsl_rng * r, double a, double b>)

This function returns a random variate
from the Pareto distribution of order I<a>. The distribution function
is, for x E<gt>= b.

=head2 Spherical Vector Distributions

The spherical distributions generate random vectors, located on a
spherical surface. They can be used as random directions, for example
in the steps of a random walk.

=head3 get_dir_2d

 void B<gsl_ran_dir_2d> (I<const gsl_rng * r, double * x, double * y>)

=head3 get_dir_2d_trig_method

 void B<gsl_ran_dir_2d_trig_method> (I<const gsl_rng * r, double * x, double * y>)

This
function returns a random direction vector v = (I<x>,I<y>) in two
dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1.
The obvious way to do this is to take a uniform random number between 0
and 2\pi and let I<x> and I<y> be the sine and cosine respectively. Two
trig functions would have been expensive in the old days, but with
modern hardware implementations, this is sometimes the fastest way to
go. This is the case for the Pentium (but not the case for the Sun
Sparcstation). One can avoid the trig evaluations by choosing I<x> and
I<y> in the interior of a unit circle (choose them at random from the
interior of the enclosing square, and then reject those that are
outside the unit circle), and then dividing by \sqrt{x^2 + y^2}. A much
cleverer approach, attributed to von Neumann (See Knuth, v2, 3rd ed,
p140, exercise 23), requires neither trig nor a square root. In this
approach, I<u> and I<v> are chosen at random from the interior of a
unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).

=head3 get_dir_3d

 void B<gsl_ran_dir_3d> (I<const gsl_rng * r, double * x, double * y, double * z>)

This
function returns a random direction vector v = (I<x>,I<y>,I<z>) in
three dimensions. The vector is normalized such that |v|^2 = x^2 + y^2
+ z^2 = 1. The method employed is due to Robert E. Knop (CACM 13, 326
(1970)), and explained in Knuth, v2, 3rd ed, p136. It uses the
surprising fact that the distribution projected along any axis is
actually uniform (this is only true for 3 dimensions).

=head3 get_dir_nd

 void B<gsl_ran_dir_nd> (I<const gsl_rng * r, size_t n, double * x>)

This function returns a random direction vector v = (x_1,x_2,...,x_n)
in I<n> dimensions. The vector is normalized such that |v|^2 = x_1^2 +
x_2^2 + ... + x_n^2 = 1. The method uses the fact that a multivariate
Gaussian distribution is spherically symmetric. Each component is
generated to have a Gaussian distribution, and then the components are
normalized. The method is described by Knuth, v2, 3rd ed, p135136, and
attributed to G. W. Brown, Modern Mathematics for the Engineer (1956).

=head2 The Weibull Distribution

=head3 get_weibull

 double B<gsl_ran_weibull> (I<const gsl_rng * r, double a, double b>)

This function returns a random
variate from the Weibull distribution. The distribution function is,
for x E<gt>= 0.

=head2 The Type-1 Gumbel Distribution

=head3 get_gumbel1

 double B<gsl_ran_gumbel1> (I<const gsl_rng * r, double a, double b>)

This
function returns a random variate from the Type-1 Gumbel distribution.
The Type-1 Gumbel distribution function is, for -\infty E<lt> x E<lt>
\infty.

=head2 The Type-2 Gumbel Distribution

=head3 get_gumbel2

 double B<gsl_ran_gumbel2> (I<const gsl_rng * r, double a, double b>)

This
function returns a random variate from the Type-2 Gumbel distribution.
The Type-2 Gumbel distribution function is, for 0 E<lt> x E<lt> \infty.

=head2 The Dirichlet Distribution

=head3 get_dirichlet

 void B<gsl_ran_dirichlet> (I<const gsl_rng * r, size_t K, const double alpha>[]I<, double theta>[])

This function returns an array of
I<K> random variates from a Dirichlet distribution of order I<K>-1. The
distribution function is for theta_i E<gt>= 0 and alpha_i E<gt> 0. The
delta function ensures that \sum \theta_i = 1. The normalization factor
Z is

The random variates are generated by sampling I<K> values from gamma
distributions with parameters a=alpha_i, b=1, and renormalizing. See
A.M. Law, W.D. Kelton, I<Simulation Modeling and Analysis> (1991).

=head2 The Poisson Distribution

=head3 get_poisson

 unsigned int B<gsl_ran_poisson> (I<const gsl_rng * r, double mu>)

This function returns a random
integer from the Poisson distribution with mean I<mu>. The probability
distribution for Poisson variates is, for k E<gt>= 0.

=head2 The Bernoulli Distribution

=head3 get_bernoulli

 unsigned int B<gsl_ran_bernoulli> (I<const gsl_rng * r, double p>)

This function returns
either 0 or 1, the result of a Bernoulli trial with probability I<p>.
The probability distribution for a Bernoulli trial is,

=head2 The Binomial Distribution

=head3 get_binomial

 unsigned int B<gsl_ran_binomial> (I<const gsl_rng * r, double p, unsigned int n>)

This function returns a random
integer from the binomial distribution, the number of successes in I<n>
independent trials with probability I<p>. The probability distribution
for binomial variates is, for 0 E<lt>= k E<lt>= n.

=head2 The Multinomial Distribution

=head3 get_multinomial

 void B<gsl_ran_multinomial> (I<const gsl_rng * r, size_t K, unsigned int N, const double p>[]I<, unsigned int n>[])

This function computes a random
sample I<n>[] from the multinomial distribution formed by I<N> trials
from an underlying distribution I<p>[I<K>]. The distribution function
for I<n>[] is, where (n_1, n_2, ..., n_K) are nonnegative integers with
sum_{k=1}^K n_k = N, and (p_1, p_2, ..., p_K) is a probability
distribution with \sum p_i = 1. If the array I<p>[I<K>] is not
normalized then its entries will be treated as weights and normalized
appropriately. The arrays I<n>[] and I<p>[] must both be of length
I<K>.

Random variates are generated using the conditional binomial method
(see C.S. Davis, I<The computer generation of multinomial random
variates>, Comp. Stat. Data Anal. 16 (1993) 205217 for details).

=head2 The Negative Binomial Distribution

=head3 get_negative_binomial

 unsigned int B<gsl_ran_negative_binomial> (I<const gsl_rng * r, double p, double n>)

This
function returns a random integer from the negative binomial
distribution, the number of failures occurring before I<n> successes in
independent trials with probability I<p> of success. The probability
distribution for negative binomial variates is, Note that n is not
required to be an integer.

=head2 The Pascal Distribution

=head3 get_pascal

 unsigned int B<gsl_ran_pascal> (I<const gsl_rng * r, double p, unsigned int n>)

This function returns a random integer from the Pascal distribution.
The Pascal distribution is simply a negative binomial distribution with
an integer value of n. for k E<gt>= 0

=head2 The Geometric Distribution

=head3 get_geometric

 unsigned int B<gsl_ran_geometric> (I<const gsl_rng * r, double p>)

This function returns a random
integer from the geometric distribution, the number of independent
trials with probability I<p> until the first success. The probability
distribution for geometric variates is, for k E<gt>= 1. Note that the
distribution begins with k=1 with this definition. There is another
convention in which the exponent k-1 is replaced by k.

=head2 The Hypergeometric Distribution

=head3 get_hypergeometric

 unsigned int B<gsl_ran_hypergeometric> (I<const gsl_rng * r, unsigned int n1, unsigned int n2, unsigned int t>)

This function returns a random
integer from the hypergeometric distribution. The probability
distribution for hypergeometric random variates is, where C(a,b) =
a!/(b!(a-b)!) and t E<lt>= n_1 + n_2. The domain of k is max(0,t-n_2),
..., min(t,n_1).

If a population contains n_1 elements of type 1 and n_2 elements of
type 2 then the hypergeometric distribution gives the probability of
obtaining k elements of type 1 in t samples from the population without
replacement.

=head2 The Logarithmic Distribution

=head3 get_logarithmic

 unsigned int B<gsl_ran_logarithmic> (I<const gsl_rng * r, double p>)

This function returns a random
integer from the logarithmic distribution. The probability distribution
for logarithmic random variates is, for k E<gt>= 1.

=head2 METHODS - Shuffling and Sampling

The following functions allow the shuffling and sampling of a set of
objects. The algorithms rely on a random number generator as a source
of randomness and a poor quality generator can lead to correlations in
the output. In particular it is important to avoid generators with a
short period. For more information see Knuth, v2, 3rd ed, Section
3.4.2, Random Sampling and Shuffling.

=head3 get_shuffle

 $self->shuffle(\@data);

This function randomly shuffles the order of I<n> objects, each of size
I<size>, stored in the array I<base>[0..I<n>-1]. The output of the
random number generator I<r> is used to produce the permutation. The
algorithm generates all possible n! permutations with equal
probability, assuming a perfect source of random numbers.

Example:

  use Math::EasyGSL::Random;  
  my $r = Math::EasyGSL::Random->new();
  my @a = map { $_ } (0..51);
  $r->shuffle(\@a);

=head3 get_choose

 @dest = $self->choose($k, \@src);

This function fills the array I<dest>[k] with I<k> objects taken
randomly from the I<n> elements of the array I<src>[0..I<n>-1]. The
objects are each of size I<size>. The output of the random number
generator I<r> is used to make the selection. The algorithm ensures all
possible samples are equally likely, assuming a perfect source of
randomness.

The objects are sampled I<without> replacement, thus each object can
only appear once in I<dest>[k]. It is required that I<k> be less than
or equal to C<n>. The objects in I<dest> will be in the same relative
order as those in I<src>. You will need to call C<gsl_ran_shuffle(r,
dest, n, size)> if you want to randomize the order.

The following code shows how to select a random sample of three unique
numbers from the set 0 to 99,

  use Math::EasyGSL::Random;  
  my $r = Math::EasyGSL::Random->new();
  my @b = map { $_ } (0..99);
  my @a = $r->choose(3, \@b);

=head3 get_sample

 @dest = $self->sample($k, \@src);

This function is like C<gsl_ran_choose> but samples I<k> items from the
original array of I<n> items I<src> with replacement, so the same
object can appear more than once in the output sequence I<dest>. There
is no requirement that I<k> be less than I<n> in this case.

